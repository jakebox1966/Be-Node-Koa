/**
 * Koa 기본 사용법
 * - Koa 애플리케이션은 미들웨어의 배열로 구성되어 있다. app.use함수는 미들웨어 함수를 애플리케이션에 등록한다.
 *
 * - Koa의 미들웨어 함수는 두 개의 파라미터를 받는다.
 * 첫 번째 파라미터 : ctx => Context의 줄임말로 웹 요청과 응답에 관한 정보를 지니고 있다.
 * 두 번째 파라미터 : next => next는 현재 처리 중인 미들웨어의 다음 미들웨어를 호출한다. 미들웨어를 등록하고
 * next 함수를 호출하지 않으면, 그 다음 미들웨어를 처리하지 않는다. 만약 미들웨어에서 next를 사용하지 않으면
 * ctx => {} 와 같은 형태로 파라미터에 next를 설정하지 않아도 된다. 주로 다음 미들웨어를 처리할 필요 없는
 * 라우트 미들웨어를 나중에 설정할 때 이러한 구조로 next를 생략한다.
 *
 * - 미들웨어는 app.use를 사용하여 등록되는 순서대로 처리된다.
 *
 * - 주소의 쿼리 파라미터를 사용하거나 웹 요청의 쿠키 혹은 헤더를 통해 분기 처리가 가능하다.
 *
 * 1. next 함수는 Promise를 반환
 * - next 함수를 호출하면 Promise를 반환한다. (Express와의 차별화되는 부분) next 함수가 반환하는
 * Promise는 다음에 처리해야 할 미들웨어가 끝나야 완료된다.
 *
 * 2. async/await 사용하기
 * - Koa는 async/await를 정식으로 지원하기 때문에 해당 문법을 아주 편하게 사용할 수 있다.
 * => 서버 사이드 렌더링을 할 때 사용했던 Express도 async/await 문법을 사용할 수 있지만, 오류를 처리하는 부분이
 *    제대로 작동하지 않을 수 있다. 백엔드 개발을 하면서 예상치 못한 에러를 제대로 잡아내려면 express-async-await라는
 *    라이브러리를 따로 사용해야 한다.
 *
 * =====================================================================
 * nodemon 사용하기
 * - 서버 코드를 변경할 때마다 서버를 재시작해야하는 nodemon이라는 도구를 사용하면 코드를 변경할 때마다 서버를 자동으로
 *   재시작 해준다.
 * - start 스크립트에는 서버를 시작하는 명령어를 넣고, start:dev 스크립트에는 nodemon을 통해 서버를 실행해 주는 명령어를 넣어준다.
 *   여기서 nodemon은 src 디렉터리를 주시하고 있다가 해당 디렉터리 내부의 어떤 파일이 변경되면, 이를 감지하여 src/index.js 파일을
 *   재시작 해준다.
 * =====================================================================
 *
 * Koa-router 사용하기
 * - 리액트에서는 웹 브라우저의 라우팅을 돕는 리액트 라우터 라이브러리를 사용했다. Koa를 사용할 때도 다른 주소로 요청이 들어올 경우
 *   다른 작업을 처리할 수 있도록 라우터를 사용해야하는데 Koa 자체에 이 기능이 내장되어 있지는 않기때문에 koa-router 모듈을 설치해줘야한다.
 *
 * - 라우트를 설정할 때, router.get의 첫 번째 파라미터에는 라우트의 경로를 넣고, 두 번째 파라미터에는 해당 라우트에 적용할 미들웨어 함수를 넣는다.
 *   여기서 get 키워드는 해당 라우트에서 사용할 HTTP 메서드를 의미한다. (get, post, put, delete)
 *
 * - 라우트 파라미터를 설정할 때는 /about/:name 형식으로 콜론(:) 을 사용하여 라우트 경로를 설정한다. 또한 파라미터가 있을 수도 있고
 *   없을 수도 있다면 /about/:name? 같은 형식으로 파라미터 이름 뒤에 물음표를 사용한다. 이렇게 설정한 파라미터는 함수의 ctx.params 객체에서
 *   조회할 수 있다.
 *
 * - URL 쿼리의 경우, 예를 들어 /posts/?id=10 같은 형식으로 요청했다면 해당 값을 ctx.query에서 조회할 수 있다. 쿼리 문자열을 자동으로 객체 형태로
 *   파싱해 주므로 별도로 파싱 함수를 돌릴 필요가 없다.(문자열 형태의 쿼리 문자열을 조회해야 할 때는 ctx.querystring을 사용)
 *
 * - 파라미터로 쿼리는 둘 다 주소를 통해 특정 값을 받아 올 때 사용하지만 용도가 서로 조금씩 다르다. 정해진 규칙은 없지만 일반적으로
 *   파라미터는 처리할 작업의 카테고리를 받아 오거나, 고유 ID 혹은 이름으로 특정 데이터를 조회할 때 사용한다. 반면, 쿼리는 옵션에
 *   관련된 정보를 받아 온다. 예를 들어 여러 항목을 리스팅하는 API라면, 어떤 조건을 만족하는 항목을 보여 줄지 또는 어떤 기준으로
 *   정렬할지를 정해야 할 때 쿼리를 사용한다.
 *
 *
 * =====================================================================
 * REST API
 *
 * - 클라이언트가 서버에 자신이 데이터를 조회.생성.삭제.업데이트하겠다고 요청하면, 서버는 필요한 로직에 따라 데이터베이스에 접근하여
 *   작업을 처리한다. 여기서 REST API를 사용하는데 REST API는 요청 종류에 따라 다른 HTTP 메소드를 사용한다.
 *   1) GET : 데이터 조회
 *   2) POST : 데이터 등록 및 인증 작업
 *   3) DELETE : 데이터 삭제
 *   4) PUT : 데이터를 새 정보로 통째로 교체
 *   5) PATCH : 데이터의 특정 필드를 수정
 *
 * - REST API를 설계할 때는 API 주소와 메소드에 따라 어떤 역할을 하는지 쉽게 파악할 수 있도록 작성해야 한다.
 * =====================================================================
 *
 * 라우트 모듈화
 *
 * - 프로젝트를 진행하다 보면 여러 종류의 라우트를 만들게 된다. 하지만 각 라우트를 index.js 파일 하나에 모두 작성하면, 코드가 너무 길어
 *   질 뿐 아니라 유지 보수하기도 힘들어진다.
 *
 * ===> 라우트 컨트롤러 파일 작성
 *
 * - 라우트를 작성하는 과정에서 특정 경로에 미들웨어를 등록할 때는 다음과 같이 두 번째 인자에 함수를 선언해서 바로 넣어 줄 수 있다.
 *      Ex)
 *          router.get('/', ctx => {
 *          })
 *   하지만 각 라우트 처리 함수의 코드가 길면 라우터 설정에 있어서 가독성이 떨어지기 때문에 라우트 처리 함수들을 다른 파일로 따로 분리해서
 *   관리할 수도 있다. (Java의 컨트롤러)
 *
 *   ** API 기능을 본격적으로 구현하기 전에 먼저 koa-bodyparser 미들웨어를 적용해야 한다. 이 미들웨어는 POST/PUT/PATCH 같은 메서드의 Request
 *      Body에 JSON 형식으로 데이터를 넣어 주면, 이를 파싱하여 서버에서 사용할 수 있게 해준다.
 *
 *      **koa-bodyparser를 적용할 때는 router를 적용하는 코드의 윗 부분에서 해야한다.
 *
 * =====================================================================
 * 기존 리액트 프로젝트에서 사용해 오던 ES 모듈 import/export문법은 Node.js에서 아직 정식으로 지원되지 않는다. => esm 라이브러리 설치하여 사용
 * =====================================================================
 */
import dotenv from 'dotenv'
dotenv.config()

import Koa from 'koa'
import Router from 'koa-router'
import bodyParser from 'koa-bodyparser'
import mongoose from 'mongoose'

//비구조화 할당을 통해 process.env 내부 값에 대한 레퍼런스 만들기
import api from './api/index.js'
import createFakeData from './createFakeData.js'

const { PORT, MONGO_URI } = process.env
mongoose
    .connect(MONGO_URI)
    .then(() => {
        console.log('Connected to MongoDB')
        // createFakeData()
    })
    .catch((e) => {
        console.error(e)
    })

const app = new Koa()
const router = new Router()

//라우터 설정
router.use('/api', api.routes()) // api 라우트 적용 : 만들어진 api 라우터를 서버의 메인 라우터의 /api 경로로 설정

// 라우터 적용 전에 bodyParser 적용
app.use(bodyParser())

// app 인스턴스에 라우터 적용

app.use(router.routes()).use(router.allowedMethods())

//PORT가 지정되어 있지 않다면 4000을 사용
const port = PORT || 4000
app.listen(port, () => {
    console.log(port)
    console.log('Listening to port %d http://localhost:%d', port, port)
})
